import nnf
from src.asal_nesy.deepfa.automaton import DeepFA
from src.asal_nesy.neurasal.mnist.compile_multivar_asp import compile_sfa


def generate_constraint(values):
    import itertools

    return nnf.And((~i | ~j) for i, j in itertools.combinations(values, r=2)) & nnf.Or(
        values
    )


variables = {}
for i in range(1, 4):
    variables[i] = [nnf.Var("d{}_{}".format(i, j)) for j in range(10)]

constraint = nnf.And(map(generate_constraint, variables.values()))


def even(digit: int):
    return nnf.Or([var for var in variables[digit] if int(var.name[-1]) % 2 == 0])


def leq5(digit: int):
    return nnf.Or([var for var in variables[digit] if int(var.name[-1]) <= 5])


def leq6(digit: int):
    return nnf.Or([var for var in variables[digit] if int(var.name[-1]) <= 6])


def gt6(digit: int):
    return nnf.Or([var for var in variables[digit] if int(var.name[-1]) > 6])


def gt5(digit: int):
    return nnf.Or([var for var in variables[digit] if int(var.name[-1]) > 5])


"""
f(2,3) :- even(d1), gt_6(d2).
f(2,1) :- gt_6(d3), not f(2,3).
f(1,2) :- leq_6(d1).
f(3,1) :- gt_5(d3).
f(3,4) :- leq_5(d1), leq_5(d3).
f(2,2) :- not f(2,1), not f(2,3).
f(3,3) :- not f(3,1), not f(3,4).
f(1,1) :- not f(1,2).
f(4,4) :- #true.
"""

# f23 = even(1) & gt6(2)
# f21 = gt6(3) & f23.negate()
# f12 = leq6(1)
# f31 = gt5(3)
# f34 = leq5(1) & leq5(3)
# f22 = f21.negate() & f23.negate()
# f33 = f31.negate() & f34.negate()
# f11 = f12.negate()

# use something like this to compile learnt automata.
d = {'even(1)': even(1), 'gt6(2)': gt6(2), 'gt6(3)': gt6(3),
     'leq6(1)': leq6(1), 'leq5(1)': leq5(1), 'leq5(3)': leq5(3), 'gt5(3)': gt5(3)}

f23 = d['even(1)'] & d['gt6(2)']
f21 = d['gt6(3)'] & f23.negate()
f12 = d['leq6(1)']
f31 = d['gt5(3)']
f34 = d['leq5(1)'] & d['leq5(3)']
f22 = f21.negate() & f23.negate()
f33 = f31.negate() & f34.negate()
f11 = f12.negate()


def get_sfa():
    deepfa = DeepFA(
        {
            1: {1: f11 & constraint, 2: f12 & constraint},
            2: {1: f21 & constraint, 2: f22 & constraint, 3: f23 & constraint},
            3: {1: f31 & constraint, 3: f33 & constraint, 4: f34 & constraint},
            4: {4: nnf.true & constraint},
        },
        1,
        {4},
    )
    return deepfa


if __name__ == '__main__':
    deepfa = get_sfa()
    print(f'\nCompiled SFA: {deepfa.transitions}\nStates: {deepfa.states}\nSymbols: {deepfa.symbols}')

    sfa_small = deepfa
    sfa_large = compile_sfa()

    # check if the circuits generated by asp and nnf are equivalent (they are). Takes a lot of time!
    print(sfa_large.transitions[1][1].equivalent(sfa_small.transitions[0][0]))
    print(sfa_large.transitions[1][2].equivalent(sfa_small.transitions[0][1]))
    print(sfa_large.transitions[2][2].equivalent(sfa_small.transitions[1][1]))
    print(sfa_large.transitions[2][1].equivalent(sfa_small.transitions[1][0]))
    print(sfa_large.transitions[2][3].equivalent(sfa_small.transitions[1][2]))
    print(sfa_large.transitions[3][1].equivalent(sfa_small.transitions[2][0]))
    print(sfa_large.transitions[3][3].equivalent(sfa_small.transitions[2][2]))
    print(sfa_large.transitions[3][4].equivalent(sfa_small.transitions[2][3]))
    print(sfa_large.transitions[4][4].equivalent(sfa_small.transitions[3][3]))
